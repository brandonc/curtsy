<!DOCTYPE html />
<html>
<head>
	<title>StringRegexExtensions.cs</title>
	<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
	<link href="..\explain.css" rel="stylesheet" media="all" type="text/css" />
	<script src="..\prettify.js" type="text/javascript"></script>
</head>
<body onload="prettyPrint()">
	<div id="container">
		<div id="background"></div>
			<div id="jump_to">
				Jump To &hellip;
				<div id="jump_wrapper">
					<div id="jump_page">
							<a class="source" href="../Extensions/StringRegexExtensions.html">
								Extensions\StringRegexExtensions.cs
							</a>
							<a class="source" href="../PathHelper.html">
								PathHelper.cs
							</a>
							<a class="source" href="../Program.html">
								Program.cs
							</a>
							<a class="source" href="../Properties/AssemblyInfo.html">
								Properties\AssemblyInfo.cs
							</a>
							<a class="source" href="../TemplateBase.html">
								TemplateBase.cs
							</a>
							<a class="source" href="../TypeMap.html">
								TypeMap.cs
							</a>
					</div>
				</div>
			</div>
		<table cellpadding="0" cellspacing="0">
			<thead>
				<tr>
					<th class="docs">
						<h1>StringRegexExtensions.cs</h1>
					</th>
					<th class="code"></th>
				</tr>
			</thead>
			<tbody>
					<tr id="section_1">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_1">&#182;</a>
							</div>
							<p>Uncomment the next line depending on your environment (Mono, Visual Studio 2008, .NET 3.5)</p>

<h1>define NET35</h1>

<p>Use .NET 4.0 to enable thread safe cacheing.</p>

<p>Copyright (c)2011 Brandon Croft and contributors</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>using System.Linq;
using System.Collections.Generic;
using System.Collections;
using System.Text.RegularExpressions;
#if !NET35
using System.Collections.Concurrent;
#endif

namespace System
{
    public class MatchData : IEnumerable&lt;string&gt;
    {
        List&lt;Capture&gt; indexcaptures = new List&lt;Capture&gt;();
        Dictionary&lt;string, Capture&gt; namedcaptures = null;

        public string this[int index]
        {
            get
            {
                try
                {
                    return indexcaptures[index].Value;
                } catch (ArgumentOutOfRangeException ex)
                {
                    throw new IndexOutOfRangeException(String.Format(&quot;The index {0} was out of range&quot;, index), ex);
                }
            }
        }

        public string this[string name]
        {
            get
            {
                Capture result = null;
                if (namedcaptures == null || !namedcaptures.TryGetValue(name, out result))
                    return null;

                return result.Value;
            }
        }

        public int Begin(int index)
        {
            try
            {
                Capture cap = indexcaptures[index];
                return cap.Index;
            } catch (ArgumentOutOfRangeException ex)
            {
                throw new IndexOutOfRangeException(String.Format(&quot;The index {0} was out of range&quot;, index), ex);
            }
        }

        public int End(int index)
        {
            try
            {
                Capture cap = indexcaptures[index];
                return cap.Index + cap.Length;
            } catch (ArgumentOutOfRangeException ex)
            {
                throw new IndexOutOfRangeException(String.Format(&quot;The index {0} was out of range&quot;, index), ex);
            }
        }

        public int Begin(string name)
        {
            Capture cap;
            if(namedcaptures == null || !namedcaptures.TryGetValue(name, out cap))
                return -1;
            
            return cap.Index;
        }

        public int End(string name)
        {
            Capture cap;
            if (namedcaptures == null || !namedcaptures.TryGetValue(name, out cap))
                return -1;

            return cap.Index + cap.Length;
        }

        public int Count
        {
            get { return indexcaptures.Count + (namedcaptures == null ? 0 : namedcaptures.Count); }
        }

        public int MatchCount
        {
            get { return indexcaptures.Count; }
        }

        public string[] GetNames()
        {
            if(namedcaptures == null)
                return new string[0];

            return this.namedcaptures.Keys.ToArray();
        }

        void AddMatch(Regex regex, Match match)
        {
            if (!match.Success)
                return;

            for (int index = 0; index &lt; match.Groups.Count; index++)
            {
                Group group = match.Groups[index];
                if (group.Captures.Count == 0)
                {
                    continue;
                }

                string name = regex.GroupNameFromNumber(index);
                int tryint;

</code></pre>
						</td>
					</tr>
					<tr id="section_2">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_2">&#182;</a>
							</div>
							<p>We only record the LAST capture in this group. This simplifies matching so
that multiple captures in the same group are overwritten.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>                if (Int32.TryParse(name, out tryint))
                {
                    this.indexcaptures.Add(group.Captures[group.Captures.Count - 1]);
                }
                else
                {
                    if (namedcaptures == null)
                        namedcaptures = new Dictionary&lt;string, Capture&gt;();

                    this.namedcaptures[name] = group.Captures[group.Captures.Count - 1];
                }
            }
        }

        IEnumerable&lt;Capture&gt; GetCaptures()
        {
</code></pre>
						</td>
					</tr>
					<tr id="section_3">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_3">&#182;</a>
							</div>
							<p>First return numbered capture values...</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>            foreach (Capture capture in indexcaptures)
            {
                yield return capture;
            }

</code></pre>
						</td>
					</tr>
					<tr id="section_4">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_4">&#182;</a>
							</div>
							<p>...then return named captures</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>            if (namedcaptures != null)
            {
                foreach (KeyValuePair&lt;string, Capture&gt; capture in namedcaptures)
                {
                    yield return capture.Value;
                }
            }
        }

        IEnumerator&lt;string&gt; GetEnumeratorInternal()
        {
            foreach (Capture cap in GetCaptures())
            {
                yield return cap.Value;
            }
        }

        public IEnumerator&lt;string&gt; GetEnumerator()
        {
            return GetEnumeratorInternal();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumeratorInternal();
        }

        public MatchData(Regex regex, MatchCollection matches)
        {
            if (matches == null || matches.Count == 0)
                return;

            foreach (Match match in matches)
            {
                AddMatch(regex, match);
            }
        }

        public MatchData(Regex regex, Match match)
        {
            AddMatch(regex, match);
        }
    }

    public static class StringRegexExtensions
    {
        static readonly Dictionary&lt;char, RegexOptions&gt; _optionChars = new Dictionary&lt;char, RegexOptions&gt; {
            { &#39;i&#39;, RegexOptions.IgnoreCase },
            { &#39;s&#39;, RegexOptions.Singleline },
            { &#39;m&#39;, RegexOptions.Multiline },
            { &#39;x&#39;, RegexOptions.IgnorePatternWhitespace },
            { &#39;c&#39;, RegexOptions.Compiled },
            { &#39;r&#39;, RegexOptions.RightToLeft }
        };

#if !NET35
        static readonly ConcurrentDictionary&lt;Tuple&lt;string, RegexOptions&gt;, Regex&gt; _cache = new ConcurrentDictionary&lt;Tuple&lt;string, RegexOptions&gt;, Regex&gt;();

        static Tuple&lt;string, RegexOptions&gt; MakeCacheKey(string pattern, RegexOptions opt)
        {
            return new Tuple&lt;string, RegexOptions&gt;(pattern, opt);
        }

        static Tuple&lt;string, RegexOptions&gt; MakeCacheKey(string pattern)
        {
            return new Tuple&lt;string, RegexOptions&gt;(pattern, RegexOptions.None);
        }

        static Regex ToRegex(this string pattern)
        {
            return _cache.GetOrAdd(MakeCacheKey(pattern), p =&gt;
            {
                return new Regex(pattern);
            });
        }

        static Regex ToRegex(this string pattern, RegexOptions options)
        {
            return _cache.GetOrAdd(MakeCacheKey(pattern, options), p =&gt;
            {
                return new Regex(pattern, options);
            });
        }

        public static int CacheCount
        {
            get
            {
                return _cache.Count;
            }
        }
#else
        static Regex ToRegex(this string pattern)
        {
            return new Regex(pattern);
        }

        static Regex ToRegex(this string pattern, RegexOptions options)
        {
            return new Regex(pattern, options);
        }
#endif

        static RegexOptions GetOptions(string options)
        {
            if (String.IsNullOrEmpty(options))
                return RegexOptions.None;

            return (RegexOptions)options.Select(c =&gt; {
                try { return (int)_optionChars[c]; } catch (KeyNotFoundException) { return 0; }
            }).Sum();
        }

        public static bool HasPattern(this string input, string pattern)
        {
            return HasPattern(input, pattern, null);
        }

        public static bool HasPattern(this string input, string pattern, string options)
        {
            return pattern.ToRegex(GetOptions(options)).IsMatch(input);
        }

        public static bool HasPattern(this string input, string pattern, int startat)
        {
            return HasPattern(input, pattern, null, startat);
        }

        public static bool HasPattern(this string input, string pattern, string options, int startat)
        {
            return pattern.ToRegex(GetOptions(options)).IsMatch(input, startat);
        }

        public static MatchData MatchesPattern(this string input, string pattern)
        {
            return MatchesPattern(input, pattern, null);
        }

        public static MatchData MatchesPattern(this string input, string pattern, string options)
        {
            var re = pattern.ToRegex(GetOptions(options));
            return new MatchData(re, re.Matches(input));
        }

        public static MatchData MatchesPattern(this string input, string pattern, int startat)
        {
            return MatchesPattern(input, pattern, null, startat);
        }

        public static MatchData MatchesPattern(this string input, string pattern, string options, int startat)
        {
            var re = pattern.ToRegex(GetOptions(options));
            return new MatchData(re, re.Matches(input, startat));
        }

        public static string Sub(this string input, string pattern, string replacement)
        {
            return Sub(input, pattern, null, replacement);
        }

        public static string Sub(this string input, string pattern, string options, string replacement)
        {
            return pattern.ToRegex(GetOptions(options)).Replace(input, replacement, 1);
        }

        public static string Sub(this string input, string pattern, Func&lt;Match, string&gt; evaluator)
        {
            return Sub(input, pattern, null, evaluator);
        }

        public static string Sub(this string input, string pattern, string options, Func&lt;Match, string&gt; evaluator)
        {
            return pattern.ToRegex(GetOptions(options)).Replace(input, delegate(Match arg) { return evaluator(arg); }, 1);
        }

        public static string GSub(this string input, string pattern, string replacement)
        {
            return GSub(input, pattern, null, replacement);
        }

        public static string GSub(this string input, string pattern, string options, string replacement)
        {
            return pattern.ToRegex(GetOptions(options)).Replace(input, replacement);
        }

        public static string GSub(this string input, string pattern, Func&lt;Match, string&gt; evaluator)
        {
            return GSub(input, pattern, null, evaluator);
        }

        public static string GSub(this string input, string pattern, string options, Func&lt;Match, string&gt; evaluator)
        {
            return pattern.ToRegex(GetOptions(options)).Replace(input, delegate(Match arg) { return evaluator(arg); });
        }

        public static int IndexOfPattern(this string input, string pattern)
        {
            return IndexOfPattern(input, pattern, null);
        }

        public static int IndexOfPattern(this string input, string pattern, string options)
        {
            return input.MatchPattern(pattern, options).Begin(0);
        }

        public static int IndexOfPattern(this string input, string pattern, int startat)
        {
            return IndexOfPattern(input, pattern, null, startat);
        }

        public static int IndexOfPattern(this string input, string pattern, string options, int startat)
        {
            return input.MatchPattern(pattern, options, startat).Begin(0);
        }

        public static int LastIndexOfPattern(this string input, string pattern)
        {
            return LastIndexOfPattern(input, pattern, null);
        }

        public static int LastIndexOfPattern(this string input, string pattern, string options)
        {
            var m = input.MatchesPattern(pattern, options);
            return m.Begin(m.MatchCount - 1);
        }

        public static string FindPattern(this string input, string pattern)
        {
            return input.MatchPattern(pattern).First();
        }

        public static string FindPattern(this string input, string pattern, string options)
        {
            return input.MatchPattern(pattern, options).First();
        }

        public static string FindPattern(this string input, string pattern, int capture)
        {
            return FindPattern(input, pattern, null, capture);
        }

        public static string FindPattern(this string input, string pattern, string options, int capture)
        {
            try { return input.MatchPattern(pattern, options)[capture]; } catch (IndexOutOfRangeException) { return null; }
        }

        public static string[] Partition(this string input, string pattern)
        {
            return Partition(input, pattern, null);
        }

        public static string[] Partition(this string input, string pattern, string options)
        {
            var m = input.MatchPattern(pattern, options);
            if (m.Count == 0)
                return new string[] { String.Empty, String.Empty, input };

            return new string[] { input.Substring(0, m.Begin(0)), m.First(), input.Substring(m.End(0)) };
        }

        public static void Scan(this string input, string pattern, Action&lt;string&gt; each)
        {
            input.Scan(pattern, null, each);
        }

        public static void Scan(this string input, string pattern, Action&lt;string, string&gt; each)
        {
            input.Scan(pattern, null, each);
        }

        public static void Scan(this string input, string pattern, Action&lt;string, string, string&gt; each)
        {
            input.Scan(pattern, null, each);
        }

        public static void Scan(this string input, string pattern, Action&lt;string, string, string, string&gt; each)
        {
            input.Scan(pattern, null, each);
        }

        public static void Scan(this string input, string pattern, string options, Action&lt;string&gt; each)
        {
            var matches = pattern.ToRegex(GetOptions(options)).Matches(input);
            foreach (Match match in matches)
            {
                each(match.Groups.Count &gt; 1 ? match.Groups[1].Value : match.Value);
            }
        }

        public static void Scan(this string input, string pattern, string options, Action&lt;string, string&gt; each)
        {
            var matches = pattern.ToRegex(GetOptions(options)).Matches(input);
            foreach (Match match in matches)
            {
                if (match.Groups.Count &gt; 2)
                    each(match.Groups[1].Value, match.Groups[2].Value);
                else
                    each(match.Value, null);
            }
        }

        public static void Scan(this string input, string pattern, string options, Action&lt;string, string, string&gt; each)
        {
            var matches = pattern.ToRegex(GetOptions(options)).Matches(input);
            foreach (Match match in matches)
            {
                if (match.Groups.Count &gt; 3)
                    each(match.Groups[1].Value, match.Groups[2].Value, match.Groups[3].Value);
                else if (match.Groups.Count &gt; 2)
                    each(match.Groups[1].Value, match.Groups[2].Value, null);
                else
                    each(match.Value, null, null);
            }
        }

        public static void Scan(this string input, string pattern, string options, Action&lt;string, string, string, string&gt; each)
        {
            var matches = pattern.ToRegex(GetOptions(options)).Matches(input);
            foreach (Match match in matches)
            {
                if(match.Groups.Count &gt; 4)
                    each(match.Groups[1].Value, match.Groups[2].Value, match.Groups[3].Value, match.Groups[4].Value);
                else if (match.Groups.Count &gt; 3)
                    each(match.Groups[1].Value, match.Groups[2].Value, match.Groups[3].Value, null);
                else if (match.Groups.Count &gt; 2)
                    each(match.Groups[1].Value, match.Groups[2].Value, null, null);
                else
                    each(match.Value, null, null, null);
            }
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_5">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_5">&#182;</a>
							</div>
							<p>Single match, used internally</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        static MatchData MatchPattern(this string input, string pattern)
        {
            return MatchPattern(input, pattern, null);
        }

        static MatchData MatchPattern(this string input, string pattern, string options)
        {
            var re = pattern.ToRegex(GetOptions(options));
            return new MatchData(re, re.Match(input));
        }

        static MatchData MatchPattern(this string input, string pattern, int startat)
        {
            return MatchPattern(input, pattern, null, startat);
        }

        static MatchData MatchPattern(this string input, string pattern, string options, int startat)
        {
            var re = pattern.ToRegex(GetOptions(options));
            return new MatchData(re, re.Match(input, startat));
        }
    }
}
</code></pre>
						</td>
					</tr>
			</tbody>
		</table>
	</div>
</body>
</html>