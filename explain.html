<!DOCTYPE html />
<html>
<head>
	<title>Explain.cs</title>
	<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
	<link href="explain.css" rel="stylesheet" media="all" type="text/css" />
	<script src="prettify.js" type="text/javascript"></script>
</head>
<body onload="prettyPrint()">
	<div id="container">
		<div id="background"></div>
			<div id="jump_to">
				Jump To &hellip;
				<div id="jump_wrapper">
					<div id="jump_page">
							<a class="source" href="explain.html">
								Explain.cs
							</a>
							<a class="source" href="extensions/stringregexextensions.html">
								Extensions\StringRegexExtensions.cs
							</a>
							<a class="source" href="parser,lexer.html">
								Parser,Lexer.cs
							</a>
							<a class="source" href="pathhelper.html">
								PathHelper.cs
							</a>
							<a class="source" href="program.html">
								Program.cs
							</a>
							<a class="source" href="properties/assemblyinfo.html">
								Properties\AssemblyInfo.cs
							</a>
							<a class="source" href="embeddedresources.html">
								EmbeddedResources.cs
							</a>
							<a class="source" href="section.html">
								Section.cs
							</a>
							<a class="source" href="templatebase.html">
								TemplateBase.cs
							</a>
							<a class="source" href="typemap.html">
								TypeMap.cs
							</a>
					</div>
				</div>
			</div>
		<table cellpadding="0" cellspacing="0">
			<thead>
				<tr>
					<th class="docs">
						<h1>Explain.cs</h1>
					</th>
					<th class="code"></th>
				</tr>
			</thead>
			<tbody>
					<tr id="section_1">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_1">&#182;</a>
							</div>
							<h2>Explain</h2>
<blockquote>
<p>A hyperlinked, readable, c#-to-annotated-html documentation generator.</p>
</blockquote>
<p>Explain is a fork of <a href="http://dontangg.github.com/nocco/">nocco</a>* that does some lexical analysis in order to provide type hyperlinking for c#.</p>

<p>Nocco is simpler and yet can be run against more programming languages, comparatively speaking. It just doesn&rsquo;t hyperlink the source.</p>

<p>This page is the result of running Explain against its own source file. The source for Explain is <a href="https://github.com/brandonc/explain">available on GitHub</a>, and released under the MIT license.</p>

<p>You can run explain either against a <code>.csproj</code> file or against individual source files.</p>

<p>Running this: <code>explain WindowsApplication1.csproj</code></p>

<p>will generate linked HTML documentation for the named source files, saving it into a new folder called &ldquo;docs&rdquo;.</p>

<p><small>* nocco is a port of <a href="http://jashkenas.github.com/docco/">docco</a>!</small></p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Text.RegularExpressions;

namespace Explain
{
    public class Explain
    {
        class OutputUnit
        {
            public string CodeFile;
            public List&lt;Section&gt; Sections;
        }

        public List&lt;string&gt; Sources { get; set; }
        public <a href="pathhelper.html">PathHelper</a> RootPathHelper { get; set; }
        public <a href="embeddedresources.html">EmbeddedResources</a> Resources { get; set; }

        public void Generate(string destinationDirectory)
        {
            <a href="typemap.html">FoundTypes</a> typeMap = new <a href="typemap.html">FoundTypes</a>();
            List&lt;OutputUnit&gt; output = new List&lt;OutputUnit&gt;();

            foreach (string codefile in this.Sources)
            {
                List&lt;Section&gt; sections = new List&lt;Section&gt;();
                var hasCode = false;
                var docsText = new StringBuilder();
                var codeText = new StringBuilder();

                Action&lt;string, string&gt; save = (string docs, string code) =&gt; sections.Add(new <a href="section.html">Section</a>() { DocsHtml = docs, CodeHtml = code });

                <a href="parser,lexer.html">FileParser</a> parser = new <a href="parser,lexer.html">FileParser</a>(codefile, typeMap, this.RootPathHelper);
                parser.EmitCommentLine += delegate(string line, int sourceLineNumber)
                {
</code></pre>
						</td>
					</tr>
					<tr id="section_2">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_2">&#182;</a>
							</div>
							<p>Throw away intellisense documentation. It doesn&rsquo;t markdown well at all.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>                    if (line.TrimStart(&#39; &#39;, &#39;\t&#39;).StartsWith(&quot;///&quot;))
                        return;

                    if (hasCode)
                    {
                        save(docsText.ToString(), codeText.ToString());
                        docsText.Clear();
                        codeText.Clear();
                        hasCode = false;
                    }

                    docsText.AppendLine(line.TrimStart(&#39; &#39;, &#39;\t&#39;, &#39;/&#39;, &#39;*&#39;));
                };

                parser.EmitLine += delegate(string line, int sourceLineNumber)
                {
                    codeText.AppendLine(line);
                    hasCode = true;
                };

                parser.Parse();
                save(docsText.ToString(), codeText.ToString());

                output.Add(new OutputUnit()
                {
                    Sections = sections,
                    CodeFile = codefile
                });
            }

            Resources.WriteClientFilesTo(destinationDirectory);

            foreach (var v in output)
            {
                GenerateInternal(v.Sections, this.Sources.ToArray(), v.CodeFile, typeMap, destinationDirectory);
            }
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_3">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_3">&#182;</a>
							</div>
							<p>Prepare sections for html output and execute razor template</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        void GenerateInternal(List&lt;Section&gt; sections, string[] sources, string codefile, <a href="typemap.html">FoundTypes</a> typeMap, string destinationDirectory)
        {
            var output = this.RootPathHelper.MakeRelativePath(codefile);
            var subdestination = Path.Combine(destinationDirectory, output);
            Directory.CreateDirectory(Path.GetDirectoryName(subdestination));

            string clientPathToRoot = String.Concat(Enumerable.Repeat&lt;string&gt;(&quot;../&quot;, output.Split(Path.DirectorySeparatorChar).Length - 1));

            Func&lt;string, string&gt; getSourcePath = (string s) =&gt;
            {
                return Path.Combine(clientPathToRoot, Path.ChangeExtension(s, &quot;.html&quot;).ToLower()).Replace(Path.DirectorySeparatorChar, &#39;/&#39;);
            };

            string typebounds = @&quot;[\s\(;:,]+&quot;;

            foreach (<a href="section.html">Section</a> s in sections)
            {
                s.DocsHtml = DownBlouse.DownBlouse.Markdownify(s.DocsHtml);
                s.CodeHtml = System.Web.HttpUtility.HtmlEncode(s.CodeHtml);

                foreach (FoundTypes.TypeInfo type in typeMap)
                {
                    string pattern;

                    if (type.Name.IndexOf(&#39;&lt;&#39;) &gt; 0)
                        pattern = &quot;(namespace)?(&quot; + typebounds + &quot;)(&quot; + type.Name.Sub(@&quot;\&lt;\w+\&gt;&quot;, @&quot;&amp;lt;\w+&amp;gt;&quot;) + &quot;)(&quot; + typebounds + &quot;)&quot;;

                    pattern = &quot;(namespace)?(&quot; + typebounds + &quot;)(&quot; + type.Name + &quot;)(&quot; + typebounds + &quot;)&quot;;

                    if (type.File != RootPathHelper.MakeRelativePath(codefile))
                        s.CodeHtml = s.CodeHtml.GSub(pattern, (Match m) =&gt; {
                            if (String.IsNullOrEmpty(m.Groups[1].Value))
                                return String.Format(&quot;{0}&lt;a href=\&quot;&quot; + getSourcePath(type.File) + &quot;\&quot;&gt;{1}&lt;/a&gt;{2}&quot;, m.Groups[2].Value, m.Groups[3].Value, m.Groups[4].Value);
                            else
                                return m.Groups[0].Value;
                        });
                }
            }

            var htmlTemplate = Resources.CreateRazorTemplateInstance();
            htmlTemplate.Title = Path.GetFileName(codefile);
            htmlTemplate.GetResourcePath = (string s) =&gt; Path.Combine(clientPathToRoot, s);
            htmlTemplate.GetSourcePath = getSourcePath;
            htmlTemplate.Sections = sections;
            htmlTemplate.Sources = new List&lt;string&gt;(from f in sources
                                                    select RootPathHelper.MakeRelativePath(f));

            htmlTemplate.Execute();

</code></pre>
						</td>
					</tr>
					<tr id="section_4">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_4">&#182;</a>
							</div>
							<p>Overwrite existing file</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>            File.WriteAllText(Path.ChangeExtension(subdestination, &quot;.html&quot;).ToLower(), htmlTemplate.Buffer.ToString());
        }

        public Explain(List&lt;string&gt; sources, string rootDirectory)
        {
            if (string.IsNullOrEmpty(rootDirectory))
                rootDirectory = &quot;.\\&quot;;
            else if (rootDirectory[rootDirectory.Length - 1] != Path.DirectorySeparatorChar)
                rootDirectory += Path.DirectorySeparatorChar;
            
            if (sources == null)
                throw new ArgumentNullException(&quot;filePaths&quot;);

            if ((from f in sources
                 where !Path.IsPathRooted(f)
                 select f).Count() &gt; 0)
            {
                throw new ArgumentException(&quot;source file paths must be rooted (absolute) paths.&quot;);
            }

            this.RootPathHelper = new <a href="pathhelper.html">PathHelper</a>(rootDirectory);
            this.Resources = new <a href="embeddedresources.html">EmbeddedResources</a>();
            this.Sources = sources;
        }
    }
}

</code></pre>
						</td>
					</tr>
			</tbody>
		</table>
	</div>
</body>
</html>