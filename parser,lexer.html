<!DOCTYPE html />
<html>
<head>
	<title>Parser,Lexer.cs</title>
	<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
	<link href="explain.css" rel="stylesheet" media="all" type="text/css" />
	<script src="prettify.js" type="text/javascript"></script>
</head>
<body onload="prettyPrint()">
	<div id="container">
		<div id="background"></div>
			<div id="jump_to">
				Jump To &hellip;
				<div id="jump_wrapper">
					<div id="jump_page">
							<a class="source" href="explain.html">
								Explain.cs
							</a>
							<a class="source" href="extensions/stringregexextensions.html">
								Extensions\StringRegexExtensions.cs
							</a>
							<a class="source" href="parser,lexer.html">
								Parser,Lexer.cs
							</a>
							<a class="source" href="pathhelper.html">
								PathHelper.cs
							</a>
							<a class="source" href="program.html">
								Program.cs
							</a>
							<a class="source" href="properties/assemblyinfo.html">
								Properties\AssemblyInfo.cs
							</a>
							<a class="source" href="embeddedresources.html">
								EmbeddedResources.cs
							</a>
							<a class="source" href="section.html">
								Section.cs
							</a>
							<a class="source" href="templatebase.html">
								TemplateBase.cs
							</a>
							<a class="source" href="typemap.html">
								TypeMap.cs
							</a>
					</div>
				</div>
			</div>
		<table cellpadding="0" cellspacing="0">
			<thead>
				<tr>
					<th class="docs">
						<h1>Parser,Lexer.cs</h1>
					</th>
					<th class="code"></th>
				</tr>
			</thead>
			<tbody>
					<tr id="section_1">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_1">&#182;</a>
							</div>
							
						</td>
						<td class="code">
							<pre><code class='prettyprint'>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;

namespace Explain
{
</code></pre>
						</td>
					</tr>
					<tr id="section_2">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_2">&#182;</a>
							</div>
							<p>The tokenizer produces a <code>Queue&lt;string&gt;</code> of tokens for a specified file stream.
String literals and comments are aggregated into single tokens.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>    public class Lexer
    {
        public const char CHAR_LITERAL = &#39;\&#39;&#39;;
        public const char STRING_LITERAL = &#39;\&quot;&#39;;
        public const char BLOCK_BEGIN = &#39;{&#39;;
        public const char BLOCK_END = &#39;}&#39;;
        public const char FORWARDSLASH = &#39;/&#39;;
        public const char BACKSLASH = &#39;\\&#39;;
        public const char CR = &#39;\r&#39;;
        public const char LF = &#39;\n&#39;;
        public const char SPLAT = &#39;*&#39;;
        public const char AT = &#39;@&#39;;
        public const char GREATERTHAN = &#39;&gt;&#39;;
        public const char LESSTHAN = &#39;&lt;&#39;;
        public const char PAREN_BEGIN = &#39;(&#39;;
        public const char PAREN_END = &#39;)&#39;;
        public const char BRACKET_BEGIN = &#39;[&#39;;
        public const char BRACKET_END = &#39;]&#39;;

        public static readonly string EOL = System.Environment.NewLine;

</code></pre>
						</td>
					</tr>
					<tr id="section_3">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_3">&#182;</a>
							</div>
							<p>Continue adding characters to the specified token until an unescaped character is encountered</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        static void ChompUntil(char until, StreamReader reader, StringBuilder token)
        {
            bool isescaped = false;
            char c = Char.MinValue;
            do
            {
                isescaped = c == BACKSLASH &amp;&amp; !isescaped;
                c = (char)reader.Read();
                token.Append(c);
            } while (reader.Peek() &gt;= 0 &amp;&amp; !(c == until &amp;&amp; !isescaped));
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_4">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_4">&#182;</a>
							</div>
							<p>Continue adding characters to the specified token until string is encountered (inclusive of string)</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        static void ChompUntil(string until, StreamReader reader, StringBuilder token)
        {
            do
            {
                char c = (char)reader.Read();
                token.Append(c);
            } while (token.Length &lt; until.Length || token.ToString().Substring(token.Length - until.Length, until.Length) != until);
        }

        public static Queue&lt;string&gt; Tokenize(StreamReader reader)
        {
            var token = new StringBuilder();
            var result = new Queue&lt;string&gt;(512);

            Action pushtoken = new Action(() =&gt;
            {
                if (token.Length &gt; 0)
                {
                    result.Enqueue(token.ToString());
                    token.Clear();
                }
            });

            while (reader.Peek() &gt;= 0)
            {
                char c = (char)reader.Read();

                if (c == LF)
                {
                    pushtoken();
                    token.Append(EOL);
                    pushtoken();
                    continue;
                }

</code></pre>
						</td>
					</tr>
					<tr id="section_5">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_5">&#182;</a>
							</div>
							<p>Non-newline white space is the primary signal for the end of a token.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>                if (Char.IsWhiteSpace(c))
                {
                    pushtoken();
                    continue;
                }

</code></pre>
						</td>
					</tr>
					<tr id="section_6">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_6">&#182;</a>
							</div>
							<p><code>&ldquo;</code> or <code>@</code> signals the start of a string literal</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>                if (c == STRING_LITERAL || (c == AT &amp;&amp; (char)reader.Peek() == STRING_LITERAL))
                {
                    pushtoken();
                    token.Append(c);
                    if (c == AT)
                        token.Append((char)reader.Read());

                    ChompUntil(STRING_LITERAL, reader, token);
                    pushtoken();
                    continue;
                }

</code></pre>
						</td>
					</tr>
					<tr id="section_7">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_7">&#182;</a>
							</div>
							<p><code>&lsquo;</code> signals the start of a character literal</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>                if (c == CHAR_LITERAL)
                {
                    pushtoken();
                    token.Append(c);
                    ChompUntil(CHAR_LITERAL, reader, token);
                    pushtoken();
                    continue;
                }

</code></pre>
						</td>
					</tr>
					<tr id="section_8">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_8">&#182;</a>
							</div>
							<p><code>/*</code> signals the start of a multiline comment</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>                if (c == FORWARDSLASH &amp;&amp; (char)reader.Peek() == SPLAT)
                {
                    pushtoken();
                    token.Append(c);
                    ChompUntil(&quot;*/&quot;, reader, token);
                    pushtoken();
                    continue;
                }

</code></pre>
						</td>
					</tr>
					<tr id="section_9">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_9">&#182;</a>
							</div>
							<p><code>//</code> signals the start of a line comment</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>                if (c == FORWARDSLASH &amp;&amp; (char)reader.Peek() == FORWARDSLASH)
                {
                    token.Append(c);
                    ChompUntil(LF, reader, token);
                    while (token[token.Length - 1] == CR || token[token.Length - 1] == LF)
                    {
                        token.Remove(token.Length - 1, 1);
                    }
                    pushtoken();
                    token.Append(EOL);
                    pushtoken();
                    continue;
                }

</code></pre>
						</td>
					</tr>
					<tr id="section_10">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_10">&#182;</a>
							</div>
							<p>These characters are necessary to successfully parse type names later on.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>                if (c == BLOCK_BEGIN ||
                    c == BLOCK_END ||
                    c == GREATERTHAN ||
                    c == LESSTHAN ||
                    c == PAREN_BEGIN ||
                    c == PAREN_END ||
                    c == BRACKET_BEGIN ||
                    c == BRACKET_END)
                {
                    pushtoken();
                    token.Append(c);
                    pushtoken();
                    continue;
                }

</code></pre>
						</td>
					</tr>
					<tr id="section_11">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_11">&#182;</a>
							</div>
							<p>Making a word</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>                token.Append(c);
            }

            return result;
        }
    }

    public delegate void EmitLineEventHandler(string line, int sourceLineNumber);

</code></pre>
						</td>
					</tr>
					<tr id="section_12">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_12">&#182;</a>
							</div>
							<p>The file parser reads both the source file AND token stream to deliver
both comment and source lines via events.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>    public class FileParser
    {
        public event EmitLineEventHandler EmitLine;
        public event EmitLineEventHandler EmitCommentLine;

        readonly Queue&lt;string&gt; tokens;
        readonly string path;

        int sourceLineNumber = 0;
        <a href="typemap.html">FoundTypes</a> typeMap;
        <a href="pathhelper.html">PathHelper</a> pathHelper;

        public void Parse()
        {
            using (StreamReader reader = new StreamReader(path))
            {
                bool iscomment = false;
                string lasttoken = null;

</code></pre>
						</td>
					</tr>
					<tr id="section_13">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_13">&#182;</a>
							</div>
							<p>Helper: get the next token and raise event if it&rsquo;s a newline.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>                Func&lt;string&gt; next = new Func&lt;string&gt;(() =&gt;
                {
                    string tok = tokens.Dequeue();
                    if (tok == System.Environment.NewLine)
                    {
                        sourceLineNumber++;
                        OnEmitLine(reader.ReadLine(), iscomment);
                    }
                    return tok;
                });

</code></pre>
						</td>
					</tr>
					<tr id="section_14">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_14">&#182;</a>
							</div>
							<p>Helper: emit a multiline token</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>                Action&lt;string&gt; emitMultilineToken = new Action&lt;string&gt;((string token) =&gt;
                {
                    token.Scan(System.Environment.NewLine, (s) =&gt;
                    {
                        sourceLineNumber++;
                        OnEmitLine(reader.ReadLine(), iscomment);
                    });
                });

</code></pre>
						</td>
					</tr>
					<tr id="section_15">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_15">&#182;</a>
							</div>
							<p>Helper: move to last newline</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>                Action skipNewlines = new Action(() =&gt;
                {
                    while (tokens.Peek() == System.Environment.NewLine)
                    {
                        next();
                    }
                });

</code></pre>
						</td>
					</tr>
					<tr id="section_16">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_16">&#182;</a>
							</div>
							<p>Helper: move past block as designated by opening and closing strings. Return the block as a string.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>                Func&lt;string, string, string&gt; skipBlock = new Func&lt;string, string, string&gt;((open, close) =&gt;
                {
                    StringBuilder result = new StringBuilder();
                    string tok = null;
                    int depth = 0;
                    while (tok != close || depth &gt; 0)
                    {
                        tok = next();
                        result.Append(tok);
                        if (tok == open)
                            depth++;
                        else if (tok == close)
                            depth--;
                    }

                    return result.ToString();
                });

</code></pre>
						</td>
					</tr>
					<tr id="section_17">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_17">&#182;</a>
							</div>
							<p>Helper: move past generic decl block</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>                Func&lt;string&gt; skipGeneric = new Func&lt;string&gt;(() =&gt;
                {
                    if (tokens.Peek() == &quot;&lt;&quot;)
                    {
                        return skipBlock(&quot;&lt;&quot;, &quot;&gt;&quot;);
                    }
                    return String.Empty;
                });

</code></pre>
						</td>
					</tr>
					<tr id="section_18">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_18">&#182;</a>
							</div>
							<p>Helper: return the next token plus any possible generic portion</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>                Func&lt;string&gt; typeName = new Func&lt;string&gt;(() =&gt;
                {
                    skipNewlines();
                    return next() + skipGeneric();
                });

                string relpath = pathHelper.MakeRelativePath(this.path);

                bool islinebeginning = true;
                while (tokens.Count &gt; 0)
                {
                    string tok = next();
                    if (tok == System.Environment.NewLine)
                    {
                        islinebeginning = true;
                        continue;
                    }

                    if (tok.StartsWith(&quot;//&quot;) &amp;&amp; islinebeginning)
                    {
                        iscomment = true;
                        continue;
                    }
                    else if (tok.StartsWith(&quot;/*&quot;) &amp;&amp; islinebeginning)
                    {
                        iscomment = true;
                        emitMultilineToken(tok);
                        continue;
                    }
                    else
                    {
                        iscomment = false;
                    }

                    islinebeginning = false;

                    switch (tok)
                    {
                        case &quot;class&quot;:
                            typeMap.Add(typeName(), relpath, this.sourceLineNumber, FoundTypes.TypeHint.Class);
                            break;
                        case &quot;delegate&quot;:
                            skipNewlines();
                            string n = next();
                            if (n == &quot;{&quot; || n == &quot;(&quot;)
                            {
</code></pre>
						</td>
					</tr>
					<tr id="section_19">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_19">&#182;</a>
							</div>
							<p>Indicates anonymous delegate</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>                                break;
                            }
                            skipGeneric();
                            typeMap.Add(tokens.Peek(), relpath, this.sourceLineNumber, FoundTypes.TypeHint.Delegate);
                            break;
                        case &quot;struct&quot;:
                            if (tokens.Peek() == &quot;{&quot; || tokens.Peek() == System.Environment.NewLine)
                            {
</code></pre>
						</td>
					</tr>
					<tr id="section_20">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_20">&#182;</a>
							</div>
							<p>Indicates generic constraint</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>                                break;
                            }
                            typeMap.Add(typeName(), relpath, this.sourceLineNumber, FoundTypes.TypeHint.Struct);
                            break;
                        case &quot;enum&quot;:
                            skipNewlines();
                            typeMap.Add(tokens.Peek(), relpath, this.sourceLineNumber, FoundTypes.TypeHint.Enum);
                            break;
                        case &quot;interface&quot;:
                            skipNewlines();
                            typeMap.Add(tokens.Peek(), relpath, this.sourceLineNumber, FoundTypes.TypeHint.Interface);
                            break;
                    }
                }
                sourceLineNumber++;
                OnEmitLine(reader.ReadLine(), iscomment);
            }
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_21">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_21">&#182;</a>
							</div>
							<p>Emit either a comment or code line.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        protected void OnEmitLine(string line, bool iscomment)
        {
            if (!iscomment &amp;&amp; EmitLine != null)
                EmitLine(line, this.sourceLineNumber);
            else if (iscomment &amp;&amp; EmitCommentLine != null)
                EmitCommentLine(line, this.sourceLineNumber);
        }

        public FileParser(string path, <a href="typemap.html">FoundTypes</a> typeMap, <a href="pathhelper.html">PathHelper</a> pathHelper)
        {
            using (StreamReader reader = new StreamReader(path))
            {
                this.tokens = Lexer.Tokenize(reader);
            }

            this.typeMap = typeMap;
            this.path = path;
            this.pathHelper = pathHelper;
        }
    }
}

</code></pre>
						</td>
					</tr>
			</tbody>
		</table>
	</div>
</body>
</html>