<!DOCTYPE html />
<html>
<head>
	<title>Parser,Lexer.cs</title>
	<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
	<link href="explain.css" rel="stylesheet" media="all" type="text/css" />
	<script src="prettify.js" type="text/javascript"></script>
</head>
<body onload="prettyPrint()">
	<div id="container">
		<div id="background"></div>
			<div id="sources" class="dd">
				Parser,Lexer.cs
                <div class="ddbtn"></div>
                <header></header>
                <nav>
                    <table border="0" cellspacing="0">
							<tr>
                                <td class="size">8.35 KB</td>
                                <td><a class="source" href="explain.html">
								    Explain.cs
							    </a></td>
                            </tr>
							<tr>
                                <td class="size">37.19 KB</td>
                                <td><a class="source" href="extensions/stringregexextensions.html">
								    Extensions\StringRegexExtensions.cs
							    </a></td>
                            </tr>
							<tr>
                                <td class="size">12.34 KB</td>
                                <td><a class="source" href="parser,lexer.html">
								    Parser,Lexer.cs
							    </a></td>
                            </tr>
							<tr>
                                <td class="size">898 B</td>
                                <td><a class="source" href="pathhelper.html">
								    PathHelper.cs
							    </a></td>
                            </tr>
							<tr>
                                <td class="size">3.16 KB</td>
                                <td><a class="source" href="program.html">
								    Program.cs
							    </a></td>
                            </tr>
							<tr>
                                <td class="size">1.46 KB</td>
                                <td><a class="source" href="properties/assemblyinfo.html">
								    Properties\AssemblyInfo.cs
							    </a></td>
                            </tr>
							<tr>
                                <td class="size">3.79 KB</td>
                                <td><a class="source" href="embeddedresources.html">
								    EmbeddedResources.cs
							    </a></td>
                            </tr>
							<tr>
                                <td class="size">506 B</td>
                                <td><a class="source" href="section.html">
								    Section.cs
							    </a></td>
                            </tr>
							<tr>
                                <td class="size">1.05 KB</td>
                                <td><a class="source" href="templatebase.html">
								    TemplateBase.cs
							    </a></td>
                            </tr>
							<tr>
                                <td class="size">1.3 KB</td>
                                <td><a class="source" href="typemap.html">
								    TypeMap.cs
							    </a></td>
                            </tr>
                    </table>
				</nav>
			</div>
		<table cellpadding="0" cellspacing="0">
			<thead>
				<tr>
					<th class="docs">
						<h1>Parser,Lexer.cs</h1>
					</th>
                    <th class="lines"></th>
					<th class="code">&nbsp;</th>
				</tr>
			</thead>
			<tbody>
					<tr id="section_1">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_1">&#182;</a>
							</div>
							
						</td>
                        <td class="lines">
1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
9<br />
                        </td>
						<td class="code">
							<pre><code class='prettyprint'>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;

namespace Explain
{
</code></pre>
						</td>
					</tr>
					<tr id="section_2">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_2">&#182;</a>
							</div>
							<p>The tokenizer produces a <code>Queue&lt;string&gt;</code> of tokens for a specified file stream.
String literals and comments are aggregated into single tokens.</p>

						</td>
                        <td class="lines">
11<br />
12<br />
13<br />
14<br />
15<br />
16<br />
17<br />
18<br />
19<br />
20<br />
21<br />
22<br />
23<br />
24<br />
25<br />
26<br />
27<br />
28<br />
29<br />
30<br />
31<br />
32<br />
                        </td>
						<td class="code">
							<pre><code class='prettyprint'>    public class Lexer
    {
        public const char CHAR_LITERAL = &#39;\&#39;&#39;;
        public const char STRING_LITERAL = &#39;\&quot;&#39;;
        public const char BLOCK_BEGIN = &#39;{&#39;;
        public const char BLOCK_END = &#39;}&#39;;
        public const char FORWARDSLASH = &#39;/&#39;;
        public const char BACKSLASH = &#39;\\&#39;;
        public const char CR = &#39;\r&#39;;
        public const char LF = &#39;\n&#39;;
        public const char SPLAT = &#39;*&#39;;
        public const char AT = &#39;@&#39;;
        public const char GREATERTHAN = &#39;&gt;&#39;;
        public const char LESSTHAN = &#39;&lt;&#39;;
        public const char PAREN_BEGIN = &#39;(&#39;;
        public const char PAREN_END = &#39;)&#39;;
        public const char BRACKET_BEGIN = &#39;[&#39;;
        public const char BRACKET_END = &#39;]&#39;;

        public static readonly string EOL = System.Environment.NewLine;

</code></pre>
						</td>
					</tr>
					<tr id="section_3">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_3">&#182;</a>
							</div>
							<p>Continue adding characters to the specified token until an unescaped character is encountered</p>

						</td>
                        <td class="lines">
33<br />
34<br />
35<br />
36<br />
37<br />
38<br />
39<br />
40<br />
41<br />
42<br />
43<br />
44<br />
45<br />
                        </td>
						<td class="code">
							<pre><code class='prettyprint'>        static void ChompUntil(char until, StreamReader reader, StringBuilder token)
        {
            bool isescaped = false;
            char c = Char.MinValue;
            do
            {
                isescaped = c == BACKSLASH &amp;&amp; !isescaped;
                c = (char)reader.Read();
                token.Append(c);
            } while (reader.Peek() &gt;= 0 &amp;&amp; !(c == until &amp;&amp; !isescaped));
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_4">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_4">&#182;</a>
							</div>
							<p>Continue adding characters to the specified token until string is encountered (inclusive of string)</p>

						</td>
                        <td class="lines">
46<br />
47<br />
48<br />
49<br />
50<br />
51<br />
52<br />
53<br />
54<br />
55<br />
56<br />
57<br />
58<br />
59<br />
60<br />
61<br />
62<br />
63<br />
64<br />
65<br />
66<br />
67<br />
68<br />
69<br />
70<br />
71<br />
72<br />
73<br />
74<br />
75<br />
76<br />
77<br />
78<br />
79<br />
80<br />
81<br />
                        </td>
						<td class="code">
							<pre><code class='prettyprint'>        static void ChompUntil(string until, StreamReader reader, StringBuilder token)
        {
            do
            {
                char c = (char)reader.Read();
                token.Append(c);
            } while (token.Length &lt; until.Length || token.ToString().Substring(token.Length - until.Length, until.Length) != until);
        }

        public static Queue&lt;string&gt; Tokenize(StreamReader reader)
        {
            var token = new StringBuilder();
            var result = new Queue&lt;string&gt;(512);

            Action pushtoken = new Action(() =&gt;
            {
                if (token.Length &gt; 0)
                {
                    result.Enqueue(token.ToString());
                    token.Clear();
                }
            });

            while (reader.Peek() &gt;= 0)
            {
                char c = (char)reader.Read();

                if (c == LF)
                {
                    pushtoken();
                    token.Append(EOL);
                    pushtoken();
                    continue;
                }

</code></pre>
						</td>
					</tr>
					<tr id="section_5">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_5">&#182;</a>
							</div>
							<p>Non-newline white space is the primary signal for the end of a token.</p>

						</td>
                        <td class="lines">
82<br />
83<br />
84<br />
85<br />
86<br />
87<br />
88<br />
                        </td>
						<td class="code">
							<pre><code class='prettyprint'>                if (Char.IsWhiteSpace(c))
                {
                    pushtoken();
                    continue;
                }

</code></pre>
						</td>
					</tr>
					<tr id="section_6">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_6">&#182;</a>
							</div>
							<p><code>&ldquo;</code> or <code>@</code> signals the start of a string literal</p>

						</td>
                        <td class="lines">
89<br />
90<br />
91<br />
92<br />
93<br />
94<br />
95<br />
96<br />
97<br />
98<br />
99<br />
100<br />
101<br />
                        </td>
						<td class="code">
							<pre><code class='prettyprint'>                if (c == STRING_LITERAL || (c == AT &amp;&amp; (char)reader.Peek() == STRING_LITERAL))
                {
                    pushtoken();
                    token.Append(c);
                    if (c == AT)
                        token.Append((char)reader.Read());

                    ChompUntil(STRING_LITERAL, reader, token);
                    pushtoken();
                    continue;
                }

</code></pre>
						</td>
					</tr>
					<tr id="section_7">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_7">&#182;</a>
							</div>
							<p><code>&lsquo;</code> signals the start of a character literal</p>

						</td>
                        <td class="lines">
102<br />
103<br />
104<br />
105<br />
106<br />
107<br />
108<br />
109<br />
110<br />
111<br />
                        </td>
						<td class="code">
							<pre><code class='prettyprint'>                if (c == CHAR_LITERAL)
                {
                    pushtoken();
                    token.Append(c);
                    ChompUntil(CHAR_LITERAL, reader, token);
                    pushtoken();
                    continue;
                }

</code></pre>
						</td>
					</tr>
					<tr id="section_8">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_8">&#182;</a>
							</div>
							<p><code>/*</code> signals the start of a multiline comment</p>

						</td>
                        <td class="lines">
112<br />
113<br />
114<br />
115<br />
116<br />
117<br />
118<br />
119<br />
120<br />
121<br />
                        </td>
						<td class="code">
							<pre><code class='prettyprint'>                if (c == FORWARDSLASH &amp;&amp; (char)reader.Peek() == SPLAT)
                {
                    pushtoken();
                    token.Append(c);
                    ChompUntil(&quot;*/&quot;, reader, token);
                    pushtoken();
                    continue;
                }

</code></pre>
						</td>
					</tr>
					<tr id="section_9">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_9">&#182;</a>
							</div>
							<p><code>//</code> signals the start of a line comment</p>

						</td>
                        <td class="lines">
122<br />
123<br />
124<br />
125<br />
126<br />
127<br />
128<br />
129<br />
130<br />
131<br />
132<br />
133<br />
134<br />
135<br />
136<br />
                        </td>
						<td class="code">
							<pre><code class='prettyprint'>                if (c == FORWARDSLASH &amp;&amp; (char)reader.Peek() == FORWARDSLASH)
                {
                    token.Append(c);
                    ChompUntil(LF, reader, token);
                    while (token[token.Length - 1] == CR || token[token.Length - 1] == LF)
                    {
                        token.Remove(token.Length - 1, 1);
                    }
                    pushtoken();
                    token.Append(EOL);
                    pushtoken();
                    continue;
                }

</code></pre>
						</td>
					</tr>
					<tr id="section_10">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_10">&#182;</a>
							</div>
							<p>These characters are necessary to successfully parse type names later on.</p>

						</td>
                        <td class="lines">
137<br />
138<br />
139<br />
140<br />
141<br />
142<br />
143<br />
144<br />
145<br />
146<br />
147<br />
148<br />
149<br />
150<br />
151<br />
152<br />
                        </td>
						<td class="code">
							<pre><code class='prettyprint'>                if (c == BLOCK_BEGIN ||
                    c == BLOCK_END ||
                    c == GREATERTHAN ||
                    c == LESSTHAN ||
                    c == PAREN_BEGIN ||
                    c == PAREN_END ||
                    c == BRACKET_BEGIN ||
                    c == BRACKET_END)
                {
                    pushtoken();
                    token.Append(c);
                    pushtoken();
                    continue;
                }

</code></pre>
						</td>
					</tr>
					<tr id="section_11">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_11">&#182;</a>
							</div>
							<p>Making a word</p>

						</td>
                        <td class="lines">
153<br />
154<br />
155<br />
156<br />
157<br />
158<br />
159<br />
160<br />
161<br />
162<br />
                        </td>
						<td class="code">
							<pre><code class='prettyprint'>                token.Append(c);
            }

            return result;
        }
    }

    public delegate void EmitLineEventHandler(string line, int sourceLineNumber);

</code></pre>
						</td>
					</tr>
					<tr id="section_12">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_12">&#182;</a>
							</div>
							<p>The file parser reads both the source file AND token stream to deliver
both comment and source lines via events.</p>

						</td>
                        <td class="lines">
164<br />
165<br />
166<br />
167<br />
168<br />
169<br />
170<br />
171<br />
172<br />
173<br />
174<br />
175<br />
176<br />
177<br />
178<br />
179<br />
180<br />
181<br />
182<br />
                        </td>
						<td class="code">
							<pre><code class='prettyprint'>    public class FileParser
    {
        public event EmitLineEventHandler EmitLine;
        public event EmitLineEventHandler EmitCommentLine;

        readonly Queue&lt;string&gt; tokens;
        readonly string path;

        int sourceLineNumber = 0;
        <a href="typemap.html">FoundTypes</a> typeMap;
        <a href="pathhelper.html">PathHelper</a> pathHelper;

        public void Parse()
        {
            using (StreamReader reader = new StreamReader(path))
            {
                bool iscomment = false;

</code></pre>
						</td>
					</tr>
					<tr id="section_13">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_13">&#182;</a>
							</div>
							<p>Helper: get the next token and raise event if it&rsquo;s a newline.</p>

						</td>
                        <td class="lines">
183<br />
184<br />
185<br />
186<br />
187<br />
188<br />
189<br />
190<br />
191<br />
192<br />
193<br />
194<br />
                        </td>
						<td class="code">
							<pre><code class='prettyprint'>                Func&lt;string&gt; next = new Func&lt;string&gt;(() =&gt;
                {
                    string tok = tokens.Dequeue();
                    if (tok == System.Environment.NewLine)
                    {
                        sourceLineNumber++;
                        OnEmitLine(reader.ReadLine(), iscomment);
                    }
                    return tok;
                });

</code></pre>
						</td>
					</tr>
					<tr id="section_14">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_14">&#182;</a>
							</div>
							<p>Helper: emit a multiline token</p>

						</td>
                        <td class="lines">
195<br />
196<br />
197<br />
198<br />
199<br />
200<br />
201<br />
202<br />
203<br />
204<br />
                        </td>
						<td class="code">
							<pre><code class='prettyprint'>                Action&lt;string&gt; emitMultilineToken = new Action&lt;string&gt;((string token) =&gt;
                {
                    token.Scan(System.Environment.NewLine, (s) =&gt;
                    {
                        sourceLineNumber++;
                        OnEmitLine(reader.ReadLine(), iscomment);
                    });
                });

</code></pre>
						</td>
					</tr>
					<tr id="section_15">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_15">&#182;</a>
							</div>
							<p>Helper: move to last newline</p>

						</td>
                        <td class="lines">
205<br />
206<br />
207<br />
208<br />
209<br />
210<br />
211<br />
212<br />
213<br />
                        </td>
						<td class="code">
							<pre><code class='prettyprint'>                Action skipNewlines = new Action(() =&gt;
                {
                    while (tokens.Peek() == System.Environment.NewLine)
                    {
                        next();
                    }
                });

</code></pre>
						</td>
					</tr>
					<tr id="section_16">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_16">&#182;</a>
							</div>
							<p>Helper: move past block as designated by opening and closing strings. Return the block as a string.</p>

						</td>
                        <td class="lines">
214<br />
215<br />
216<br />
217<br />
218<br />
219<br />
220<br />
221<br />
222<br />
223<br />
224<br />
225<br />
226<br />
227<br />
228<br />
229<br />
230<br />
231<br />
232<br />
                        </td>
						<td class="code">
							<pre><code class='prettyprint'>                Func&lt;string, string, string&gt; skipBlock = new Func&lt;string, string, string&gt;((open, close) =&gt;
                {
                    StringBuilder result = new StringBuilder();
                    string tok = null;
                    int depth = 0;
                    while (tok != close || depth &gt; 0)
                    {
                        tok = next();
                        result.Append(tok);
                        if (tok == open)
                            depth++;
                        else if (tok == close)
                            depth--;
                    }

                    return result.ToString();
                });

</code></pre>
						</td>
					</tr>
					<tr id="section_17">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_17">&#182;</a>
							</div>
							<p>Helper: move past generic decl block</p>

						</td>
                        <td class="lines">
233<br />
234<br />
235<br />
236<br />
237<br />
238<br />
239<br />
240<br />
241<br />
242<br />
                        </td>
						<td class="code">
							<pre><code class='prettyprint'>                Func&lt;string&gt; skipGeneric = new Func&lt;string&gt;(() =&gt;
                {
                    if (tokens.Peek() == &quot;&lt;&quot;)
                    {
                        return skipBlock(&quot;&lt;&quot;, &quot;&gt;&quot;);
                    }
                    return String.Empty;
                });

</code></pre>
						</td>
					</tr>
					<tr id="section_18">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_18">&#182;</a>
							</div>
							<p>Helper: return the next token plus any possible generic portion</p>

						</td>
                        <td class="lines">
243<br />
244<br />
245<br />
246<br />
247<br />
248<br />
249<br />
250<br />
251<br />
252<br />
253<br />
254<br />
255<br />
256<br />
257<br />
258<br />
259<br />
260<br />
261<br />
262<br />
263<br />
264<br />
265<br />
266<br />
267<br />
268<br />
269<br />
270<br />
271<br />
272<br />
273<br />
274<br />
275<br />
276<br />
277<br />
278<br />
279<br />
280<br />
281<br />
282<br />
283<br />
284<br />
285<br />
286<br />
287<br />
288<br />
289<br />
                        </td>
						<td class="code">
							<pre><code class='prettyprint'>                Func&lt;string&gt; typeName = new Func&lt;string&gt;(() =&gt;
                {
                    skipNewlines();
                    return next() + skipGeneric();
                });

                string relpath = pathHelper.MakeRelativePath(this.path);

                bool islinebeginning = true;
                while (tokens.Count &gt; 0)
                {
                    string tok = next();
                    if (tok == System.Environment.NewLine)
                    {
                        islinebeginning = true;
                        continue;
                    }

                    if (tok.StartsWith(&quot;//&quot;) &amp;&amp; islinebeginning)
                    {
                        iscomment = true;
                        continue;
                    }
                    else if (tok.StartsWith(&quot;/*&quot;) &amp;&amp; islinebeginning)
                    {
                        iscomment = true;
                        emitMultilineToken(tok);
                        continue;
                    }
                    else
                    {
                        iscomment = false;
                    }

                    islinebeginning = false;

                    switch (tok)
                    {
                        case &quot;class&quot;:
                            typeMap.Add(typeName(), relpath, this.sourceLineNumber, FoundTypes.TypeHint.Class);
                            break;
                        case &quot;delegate&quot;:
                            skipNewlines();
                            string n = next();
                            if (n == &quot;{&quot; || n == &quot;(&quot;)
                            {
</code></pre>
						</td>
					</tr>
					<tr id="section_19">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_19">&#182;</a>
							</div>
							<p>Indicates anonymous delegate</p>

						</td>
                        <td class="lines">
290<br />
291<br />
292<br />
293<br />
294<br />
295<br />
296<br />
297<br />
298<br />
                        </td>
						<td class="code">
							<pre><code class='prettyprint'>                                break;
                            }
                            skipGeneric();
                            typeMap.Add(tokens.Peek(), relpath, this.sourceLineNumber, FoundTypes.TypeHint.Delegate);
                            break;
                        case &quot;struct&quot;:
                            if (tokens.Peek() == &quot;{&quot; || tokens.Peek() == System.Environment.NewLine)
                            {
</code></pre>
						</td>
					</tr>
					<tr id="section_20">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_20">&#182;</a>
							</div>
							<p>Indicates generic constraint</p>

						</td>
                        <td class="lines">
299<br />
300<br />
301<br />
302<br />
303<br />
304<br />
305<br />
306<br />
307<br />
308<br />
309<br />
310<br />
311<br />
312<br />
313<br />
314<br />
315<br />
316<br />
317<br />
318<br />
                        </td>
						<td class="code">
							<pre><code class='prettyprint'>                                break;
                            }
                            typeMap.Add(typeName(), relpath, this.sourceLineNumber, FoundTypes.TypeHint.Struct);
                            break;
                        case &quot;enum&quot;:
                            skipNewlines();
                            typeMap.Add(tokens.Peek(), relpath, this.sourceLineNumber, FoundTypes.TypeHint.Enum);
                            break;
                        case &quot;interface&quot;:
                            skipNewlines();
                            typeMap.Add(tokens.Peek(), relpath, this.sourceLineNumber, FoundTypes.TypeHint.Interface);
                            break;
                    }
                }
                sourceLineNumber++;
                OnEmitLine(reader.ReadLine(), iscomment);
            }
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_21">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_21">&#182;</a>
							</div>
							<p>Emit either a comment or code line.</p>

						</td>
                        <td class="lines">
319<br />
320<br />
321<br />
322<br />
323<br />
324<br />
325<br />
326<br />
327<br />
328<br />
329<br />
330<br />
331<br />
332<br />
333<br />
334<br />
335<br />
336<br />
337<br />
338<br />
339<br />
340<br />
                        </td>
						<td class="code">
							<pre><code class='prettyprint'>        protected void OnEmitLine(string line, bool iscomment)
        {
            if (!iscomment &amp;&amp; EmitLine != null)
                EmitLine(line, this.sourceLineNumber);
            else if (iscomment &amp;&amp; EmitCommentLine != null)
                EmitCommentLine(line, this.sourceLineNumber);
        }

        public FileParser(string path, <a href="typemap.html">FoundTypes</a> typeMap, <a href="pathhelper.html">PathHelper</a> pathHelper)
        {
            using (StreamReader reader = new StreamReader(path))
            {
                this.tokens = Lexer.Tokenize(reader);
            }

            this.typeMap = typeMap;
            this.path = path;
            this.pathHelper = pathHelper;
        }
    }
}

</code></pre>
						</td>
					</tr>
			</tbody>
		</table>
	</div>
</body>
</html>